> Original Source: kiro_01/specs/note-taking-feature/design.md

# Design Document: Note Taking Feature

## Overview

The Note Taking feature provides users with a persistent, accessible notepad integrated into the b1t-Sched application. The feature leverages existing markdown and linkify utilities, follows established UI patterns for floating buttons and modals, and integrates with Firebase Firestore for data persistence. The design emphasizes simplicity, accessibility, and consistency with the existing application architecture.

## Architecture

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     User Interface Layer                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ Note Button  │  │ Note Modal   │  │ Upload Sites     │  │
│  │ (Floating)   │  │ (Full/Popup) │  │ Dropdown         │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   Application Logic Layer                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ Note Manager │  │ Text         │  │ Event Handlers   │  │
│  │ (notes.js)   │  │ Formatter    │  │                  │  │
│  └──────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    Data Persistence Layer                    │
│  ┌──────────────────────────────────────────────────────┐   │
│  │         Firebase Firestore (users collection)        │   │
│  │  Document: /users/{userId}                           │   │
│  │  Field: noteContent (string)                         │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### Component Interaction Flow

1. User clicks Note Button → Note Modal opens
2. User types in textarea → Text is formatted with markdown/linkify
3. User clicks Save/Auto-save → Content persists to Firestore
4. User clicks Upload Files → Dropdown shows temporary upload sites
5. User clicks Clear → Confirmation dialog → Content cleared from UI and Firestore

## Components and Interfaces

### 1. Note Button Component

**Location**: Floating button positioned in bottom-middle (mobile) or bottom-right (desktop)

**HTML Structure**:
```html
<div id="note-toggle" class="note-toggle mobile-only">
  <i class="fas fa-sticky-note"></i>
</div>

<div id="note-button-desktop" class="note-button-desktop desktop-only">
  <i class="fas fa-sticky-note"></i>
  <span>Notes</span>
</div>
```

**CSS Styling**:
- Mobile: Follows pattern of `events-toggle`, `notice-toggle`, `classroom-toggle`
- Desktop: Bottom-right corner, similar to `total-user-counter` positioning
- Z-index: Below modals but above content
- Color scheme: Consistent with primary maroon theme

### 2. Note Modal Component

**HTML Structure**:
```html
<div id="note-modal" class="modal" style="display: none;">
  <div class="modal-content note-modal-content">
    <div class="modal-header">
      <h2 class="modal-title">
        <i class="fas fa-sticky-note"></i> My Notes
      </h2>
      <button id="close-note-modal" class="btn btn-icon">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div class="modal-body note-modal-body">
      <!-- Note Editor -->
      <div class="note-editor">
        <textarea 
          id="note-textarea" 
          class="note-textarea" 
          placeholder="Start typing your notes here... Supports markdown formatting!"
        ></textarea>
      </div>
      
      <!-- Note Preview (rendered with markdown) -->
      <div class="note-preview">
        <h3>Preview</h3>
        <div id="note-preview-content" class="note-preview-content">
          <p class="note-empty-message">Your formatted notes will appear here...</p>
        </div>
      </div>
      
      <!-- Upload Sites Section -->
      <div class="note-upload-section">
        <button id="upload-files-btn" class="btn btn-secondary">
          <i class="fas fa-upload"></i> Upload Files
        </button>
        
        <div id="upload-sites-dropdown" class="upload-sites-dropdown" style="display: none;">
          <p class="upload-instruction">
            <i class="fas fa-info-circle"></i>
            Paste links in the Note or in Task. These are temporary files, be sure to back up anything important within their expiry. Markdown link format is: [text](link)
          </p>
          <ul class="upload-sites-list">
            <li><a href="https://tmpfiles.org/" target="_blank" rel="noopener noreferrer">tmpfiles.org</a></li>
            <li><a href="https://www.file.io/" target="_blank" rel="noopener noreferrer">file.io</a></li>
            <li><a href="https://filebin.net/" target="_blank" rel="noopener noreferrer">filebin.net</a></li>
            <li><a href="https://temp.sh/" target="_blank" rel="noopener noreferrer">temp.sh</a></li>
            <li><a href="https://limewire.com/" target="_blank" rel="noopener noreferrer">limewire.com</a></li>
          </ul>
        </div>
      </div>
    </div>
    
    <div class="modal-footer">
      <button id="clear-note-btn" class="btn btn-danger">
        <i class="fas fa-trash"></i> Clear
      </button>
      <button id="save-note-btn" class="btn btn-primary">
        <i class="fas fa-save"></i> Save
      </button>
    </div>
  </div>
</div>
```

**Responsive Behavior**:
- Mobile (< 768px): Full-screen modal (`.note-modal-content` width: 100%, height: 100vh)
- Desktop (≥ 768px): Centered popup (max-width: 800px, max-height: 80vh)

### 3. Note Manager Module (notes.js)

**Interface**:
```javascript
const NoteManager = {
  // Initialize note functionality
  init() { },
  
  // Load note from Firestore
  async loadNote(userId) { },
  
  // Save note to Firestore
  async saveNote(userId, content) { },
  
  // Clear note from Firestore
  async clearNote(userId) { },
  
  // Update preview with formatted content
  updatePreview(content) { },
  
  // Auto-save functionality (debounced)
  autoSave(userId, content) { },
  
  // Show/hide modal
  openModal() { },
  closeModal() { }
};
```

**Key Methods**:

1. **init()**: Sets up event listeners for button clicks, textarea input, save/clear actions
2. **loadNote(userId)**: Fetches note content from Firestore `/users/{userId}` document
3. **saveNote(userId, content)**: Writes note content to Firestore with error handling
4. **clearNote(userId)**: Removes note content after confirmation
5. **updatePreview(content)**: Uses `Utils.escapeAndLinkify()` to render formatted preview
6. **autoSave(userId, content)**: Debounced save (500ms delay) to reduce Firestore writes

## Data Models

### Firestore Schema

**Collection**: `users`  
**Document ID**: `{userId}` (Firebase Auth UID)

**New Field**:
```javascript
{
  // Existing fields
  email: string,
  studentId: string,
  department: string,
  semester: string,
  section: string,
  role: string,
  // ... other existing fields
  
  // New field for notes
  noteContent: string,  // Stores the raw markdown text
  noteUpdatedAt: timestamp  // Last update timestamp (optional, for future features)
}
```

**Rationale for Firestore Storage**:
- User-specific data that should persist across sessions
- Consistent with existing user data storage pattern
- Enables future features (sync across devices, note history)
- Simple schema extension (single field addition)

**Alternative Considered**: localStorage
- Pros: No Firestore reads/writes, faster access
- Cons: No cross-device sync, lost on browser clear, no backup
- Decision: Use Firestore for consistency and future-proofing

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*


### Property 1: Note Content Formatting Consistency

*For any* note content containing markdown syntax or URLs, the rendered preview should correctly format bold text, italic text, inline code, markdown links, and convert plain URLs to clickable links, matching the formatting behavior used in tasks and events.

**Validates: Requirements 3.1, 3.2, 3.3, 3.4**

### Property 2: Note Persistence Round Trip

*For any* note content saved by a user, closing the note interface and reopening it should retrieve and display the exact same content from Firebase Firestore.

**Validates: Requirements 6.1, 6.2**

### Property 3: User Data Isolation

*For any* two different authenticated users, modifications to one user's note content should not affect the other user's note content, ensuring each user has their own isolated note storage.

**Validates: Requirements 4.5, 6.3**

### Property 4: Clear Operation Completeness

*For any* note content, when a user confirms the clear operation, both the UI textarea and the Firebase Firestore document should be updated to contain empty content.

**Validates: Requirements 4.3, 6.4**

### Property 5: Modal Visibility Toggle

*For any* authenticated user, clicking the note button should toggle the modal from hidden to visible, and clicking the close button should toggle it from visible to hidden.

**Validates: Requirements 1.3, 2.5**

### Property 6: Real-time Preview Update

*For any* text input in the note textarea, the preview section should update immediately to reflect the formatted version of that text.

**Validates: Requirements 4.2**

### Property 7: Upload Dropdown Toggle

*For any* state of the upload sites dropdown (visible or hidden), clicking the "Upload Files" button should toggle it to the opposite state.

**Validates: Requirements 5.2**

### Property 8: Error Notification on Save Failure

*For any* Firebase Firestore error that occurs during a save operation, the system should display a user-visible error notification indicating the save failed.

**Validates: Requirements 6.5**

### Property 9: Authenticated Access Control

*For any* authenticated user, the note button should be visible and functional, while for unauthenticated users, the note button should not be accessible.

**Validates: Requirements 1.4**

### Property 10: Responsive Functionality Preservation

*For any* viewport size (mobile or desktop), all core note-taking functionality (open, edit, save, clear, upload sites access) should remain fully operational.

**Validates: Requirements 7.3, 7.4, 7.5**

## Error Handling

### 1. Firebase Persistence Errors

**Scenarios**:
- Network connectivity issues
- Firestore permission errors
- Quota exceeded errors
- Document write failures

**Handling Strategy**:
```javascript
async saveNote(userId, content) {
  try {
    await db.collection('users').doc(userId).update({
      noteContent: content,
      noteUpdatedAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    
    // Show success feedback
    this.showMessage('Note saved successfully', 'success');
  } catch (error) {
    console.error('Error saving note:', error);
    
    // User-friendly error messages
    let errorMessage = 'Failed to save note. ';
    if (error.code === 'permission-denied') {
      errorMessage += 'You do not have permission to save notes.';
    } else if (error.code === 'unavailable') {
      errorMessage += 'Network connection issue. Please try again.';
    } else {
      errorMessage += 'Please try again later.';
    }
    
    this.showMessage(errorMessage, 'error');
  }
}
```

### 2. User Authentication Errors

**Scenarios**:
- User not authenticated when accessing notes
- Session expired during note editing

**Handling Strategy**:
- Check authentication state before any Firestore operation
- Redirect to login if session expired
- Disable note functionality for unauthenticated users

```javascript
init() {
  Auth.onAuthStateChanged((user) => {
    if (user) {
      this.enableNoteFeature(user.uid);
    } else {
      this.disableNoteFeature();
    }
  });
}
```

### 3. Content Validation Errors

**Scenarios**:
- Note content exceeds Firestore document size limit (1MB)
- Invalid characters in content

**Handling Strategy**:
```javascript
validateNoteContent(content) {
  const MAX_SIZE = 1000000; // 1MB in bytes
  const sizeInBytes = new Blob([content]).size;
  
  if (sizeInBytes > MAX_SIZE) {
    this.showMessage('Note is too large. Please reduce content size.', 'error');
    return false;
  }
  
  return true;
}
```

### 4. UI State Errors

**Scenarios**:
- Modal fails to open/close
- Preview rendering errors
- Dropdown toggle failures

**Handling Strategy**:
- Defensive programming with null checks
- Fallback to default states
- Console logging for debugging

```javascript
openModal() {
  const modal = document.getElementById('note-modal');
  if (!modal) {
    console.error('Note modal element not found');
    return;
  }
  
  modal.style.display = 'flex';
  this.loadNote(Auth.getUserId());
}
```

## Testing Strategy

### Dual Testing Approach

The note-taking feature will be validated using both unit tests and property-based tests to ensure comprehensive coverage:

- **Unit tests**: Verify specific examples, edge cases, and error conditions
- **Property tests**: Verify universal properties across all inputs
- Both approaches are complementary and necessary for complete validation

### Unit Testing

Unit tests will focus on:

1. **Specific UI Interactions**:
   - Opening/closing the modal
   - Clicking the upload files button
   - Confirming clear operation
   - Button visibility at specific viewport sizes

2. **Edge Cases**:
   - Empty note content
   - Very long note content (approaching size limits)
   - Special characters in notes
   - Rapid successive saves (debouncing)

3. **Error Conditions**:
   - Firestore permission denied
   - Network unavailable
   - Invalid user session
   - Missing DOM elements

4. **Integration Points**:
   - Markdown rendering using Utils.escapeAndLinkify()
   - Firebase authentication state changes
   - Responsive CSS breakpoints

**Example Unit Tests**:
```javascript
describe('NoteManager', () => {
  test('should open modal when note button is clicked', () => {
    const button = document.getElementById('note-toggle');
    button.click();
    const modal = document.getElementById('note-modal');
    expect(modal.style.display).toBe('flex');
  });
  
  test('should show confirmation dialog when clearing non-empty note', () => {
    const textarea = document.getElementById('note-textarea');
    textarea.value = 'Test content';
    const clearBtn = document.getElementById('clear-note-btn');
    
    window.confirm = jest.fn(() => false);
    clearBtn.click();
    
    expect(window.confirm).toHaveBeenCalled();
    expect(textarea.value).toBe('Test content'); // Not cleared
  });
  
  test('should handle Firestore permission error gracefully', async () => {
    const mockError = { code: 'permission-denied' };
    jest.spyOn(db.collection('users').doc('user123'), 'update')
      .mockRejectedValue(mockError);
    
    await NoteManager.saveNote('user123', 'Test');
    
    const message = document.querySelector('.message.error');
    expect(message.textContent).toContain('permission');
  });
});
```

### Property-Based Testing

Property tests will be configured to run a minimum of 100 iterations per test to ensure comprehensive input coverage. Each test will be tagged with a comment referencing the design document property.

**Property Test Configuration**:
- Library: fast-check (for JavaScript)
- Iterations: 100 minimum per property
- Tag format: `// Feature: note-taking-feature, Property {number}: {property_text}`

**Example Property Tests**:

```javascript
const fc = require('fast-check');

describe('Note Taking Properties', () => {
  // Feature: note-taking-feature, Property 1: Note Content Formatting Consistency
  test('markdown and URLs are consistently formatted', () => {
    fc.assert(
      fc.property(
        fc.string(), // Random note content
        (content) => {
          const formatted = Utils.escapeAndLinkify(content);
          
          // Check markdown links are converted
          const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
          const hasMarkdownLinks = markdownLinkRegex.test(content);
          if (hasMarkdownLinks) {
            expect(formatted).toContain('<a href=');
          }
          
          // Check URLs are linkified
          const urlRegex = /https?:\/\/[^\s]+/g;
          const hasUrls = urlRegex.test(content);
          if (hasUrls) {
            expect(formatted).toContain('<a href=');
          }
          
          // Check bold formatting
          if (content.includes('**')) {
            expect(formatted).toContain('<strong>');
          }
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: note-taking-feature, Property 2: Note Persistence Round Trip
  test('saved notes can be retrieved unchanged', async () => {
    fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 0, maxLength: 1000 }), // Random note content
        async (content) => {
          const userId = 'test-user-' + Math.random();
          
          // Save note
          await NoteManager.saveNote(userId, content);
          
          // Retrieve note
          const retrieved = await NoteManager.loadNote(userId);
          
          // Should match exactly
          expect(retrieved).toBe(content);
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: note-taking-feature, Property 3: User Data Isolation
  test('different users have isolated note storage', async () => {
    fc.assert(
      fc.asyncProperty(
        fc.string(), // User 1 content
        fc.string(), // User 2 content
        async (content1, content2) => {
          const userId1 = 'user-' + Math.random();
          const userId2 = 'user-' + Math.random();
          
          // Save different content for each user
          await NoteManager.saveNote(userId1, content1);
          await NoteManager.saveNote(userId2, content2);
          
          // Retrieve and verify isolation
          const retrieved1 = await NoteManager.loadNote(userId1);
          const retrieved2 = await NoteManager.loadNote(userId2);
          
          expect(retrieved1).toBe(content1);
          expect(retrieved2).toBe(content2);
          expect(retrieved1).not.toBe(retrieved2);
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: note-taking-feature, Property 4: Clear Operation Completeness
  test('clearing removes content from UI and Firestore', async () => {
    fc.assert(
      fc.asyncProperty(
        fc.string({ minLength: 1 }), // Non-empty content
        async (content) => {
          const userId = 'test-user-' + Math.random();
          
          // Save note
          await NoteManager.saveNote(userId, content);
          
          // Clear note
          await NoteManager.clearNote(userId);
          
          // Verify UI is empty
          const textarea = document.getElementById('note-textarea');
          expect(textarea.value).toBe('');
          
          // Verify Firestore is empty
          const retrieved = await NoteManager.loadNote(userId);
          expect(retrieved).toBe('');
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: note-taking-feature, Property 6: Real-time Preview Update
  test('preview updates immediately on textarea input', () => {
    fc.assert(
      fc.property(
        fc.string(),
        (content) => {
          const textarea = document.getElementById('note-textarea');
          const preview = document.getElementById('note-preview-content');
          
          // Simulate typing
          textarea.value = content;
          textarea.dispatchEvent(new Event('input'));
          
          // Preview should be updated
          const expectedPreview = Utils.escapeAndLinkify(content);
          expect(preview.innerHTML).toBe(expectedPreview);
        }
      ),
      { numRuns: 100 }
    );
  });
  
  // Feature: note-taking-feature, Property 10: Responsive Functionality Preservation
  test('all features work across viewport sizes', () => {
    fc.assert(
      fc.property(
        fc.integer({ min: 320, max: 1920 }), // Random viewport width
        (viewportWidth) => {
          // Set viewport
          window.innerWidth = viewportWidth;
          window.dispatchEvent(new Event('resize'));
          
          // Test core functionality
          const noteButton = document.getElementById('note-toggle') || 
                            document.getElementById('note-button-desktop');
          expect(noteButton).toBeTruthy();
          
          // Open modal
          noteButton.click();
          const modal = document.getElementById('note-modal');
          expect(modal.style.display).toBe('flex');
          
          // Verify textarea is accessible
          const textarea = document.getElementById('note-textarea');
          expect(textarea).toBeTruthy();
          
          // Verify buttons are accessible
          const saveBtn = document.getElementById('save-note-btn');
          const clearBtn = document.getElementById('clear-note-btn');
          expect(saveBtn).toBeTruthy();
          expect(clearBtn).toBeTruthy();
        }
      ),
      { numRuns: 100 }
    );
  });
});
```

### Test Coverage Goals

- **Unit Test Coverage**: 80%+ of note-taking code
- **Property Test Coverage**: All 10 correctness properties
- **Integration Test Coverage**: Firebase operations, authentication flow, UI interactions
- **Manual Testing**: Responsive design across real devices, accessibility with screen readers

### Testing Tools

- **Unit Testing**: Jest
- **Property-Based Testing**: fast-check
- **Integration Testing**: Jest + Firebase Emulator
- **E2E Testing**: Cypress (optional, for full user flows)
- **Accessibility Testing**: axe-core, manual screen reader testing

## Implementation Notes

### 1. Auto-Save Implementation

To reduce Firestore write operations and improve UX, implement debounced auto-save:

```javascript
autoSave: null, // Debounce timer

setupAutoSave() {
  const textarea = document.getElementById('note-textarea');
  textarea.addEventListener('input', (e) => {
    clearTimeout(this.autoSave);
    this.autoSave = setTimeout(() => {
      const userId = Auth.getUserId();
      if (userId) {
        this.saveNote(userId, e.target.value);
      }
    }, 500); // 500ms debounce
  });
}
```

### 2. CSS Positioning Strategy

**Mobile (< 768px)**:
```css
.note-toggle {
  position: fixed;
  right: 0;
  bottom: 50%; /* Center vertically */
  transform: translateY(50%);
  z-index: 900;
}
```

**Desktop (≥ 768px)**:
```css
.note-button-desktop {
  position: fixed;
  right: 20px;
  bottom: 20px;
  z-index: 900;
}
```

### 3. Modal Responsive Behavior

```css
/* Mobile: Full screen */
@media (max-width: 768px) {
  .note-modal-content {
    width: 100%;
    height: 100vh;
    max-width: none;
    max-height: none;
    border-radius: 0;
  }
}

/* Desktop: Centered popup */
@media (min-width: 769px) {
  .note-modal-content {
    max-width: 800px;
    max-height: 80vh;
    border-radius: var(--radius-lg);
  }
}
```

### 4. Integration with Existing Utils

Reuse existing text formatting utilities:

```javascript
updatePreview(content) {
  const preview = document.getElementById('note-preview-content');
  if (!content || content.trim() === '') {
    preview.innerHTML = '<p class="note-empty-message">Your formatted notes will appear here...</p>';
  } else {
    // Use existing utility from utils.js
    preview.innerHTML = Utils.escapeAndLinkify(content);
  }
}
```

### 5. Firebase Security Rules

Add security rules to protect user notes:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Validate noteContent field
      allow update: if request.auth != null 
                    && request.auth.uid == userId
                    && request.resource.data.noteContent is string
                    && request.resource.data.noteContent.size() <= 1000000; // 1MB limit
    }
  }
}
```

### 6. Accessibility Considerations

- Add ARIA labels to buttons and modal
- Ensure keyboard navigation works (Tab, Escape to close)
- Provide focus management (focus textarea when modal opens)
- Use semantic HTML elements

```html
<button 
  id="note-toggle" 
  class="note-toggle" 
  aria-label="Open notes"
  aria-expanded="false"
>
  <i class="fas fa-sticky-note" aria-hidden="true"></i>
</button>

<div 
  id="note-modal" 
  class="modal" 
  role="dialog" 
  aria-labelledby="note-modal-title"
  aria-modal="true"
>
  <h2 id="note-modal-title">My Notes</h2>
  <!-- ... -->
</div>
```

### 7. Performance Optimization

- Lazy load note content (only fetch when modal opens)
- Debounce auto-save to reduce Firestore writes
- Use CSS transforms for animations (better performance)
- Minimize DOM manipulations in preview updates

### 8. Future Enhancements

Potential features for future iterations:
- Note history/versioning
- Rich text editor (WYSIWYG)
- Note sharing between users
- Note export (PDF, Markdown file)
- Note search functionality
- Multiple notes with categories
- Offline support with service workers
